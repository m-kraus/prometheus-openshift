TODO:
* Grafana Dashboard Import
* shellscript aufräumen
* cadvisor (https://www.robustperception.io/openshift-and-prometheus/)
  * http://trustmeiamadeveloper.com/2016/07/03/bringing-the-light-of-monitoring-with-prometheus/
* node exporter
* ifconfig-Hack von Robo
eingerschränkter RAM innerhalb Limit

* HAproxy exportiert bereits metrics: https://youtu.be/5Jr1v9mWnJc?t=601



WHAT TO MONITOR:
* all pods use resources: CPU, Memory, Network, disk
* Kubernetes "meta"-information erlaubt es, Pod-Metriken zu gruppieren
*

Problem: Prom. ist agnostisch, kann alles überwachen. Entsprechend aufwändig ist es aber wieder, diesem Syste das Monitoring von APIServer, Pods, Nodes etc. beizubringen.

**Prometheus Operator**: https://github.com/coreos/prometheus-operator
**kube-prometheus** https://github.com/coreos/prometheus-operator/tree/master/contrib/kube-prometheus setzt auf operator auf (enthält Alert Rules, Dashboards etc.)

Operators: "Putting Operational Knowledge into Software" https://coreos.com/blog/introducing-operators.html

Merkmale von Operators: https://coreos.com/blog/introducing-operators.html, siehe "How can you create an Operator?" Operators sind per design applikationsspezifisch (Prmetheus, etcd, etc.)

Ausgerichtet an den Paradigmen von Kubernetes. Ziel ist es, das Monitoring nicht in Prometheus-Syntax zu coden, sondern das Monitoring selbst als Deployment zu abstrahieren.

Custom Resource Definition (CRD) = ist eine 3rd party resource "ServiceMonitor", Selector: https://youtu.be/5Jr1v9mWnJc?t=1142


Open source: Weiterentwicklung von Dashboards, Alert rules etc.
Bevor jeder sein eigenes Ding dreht.

Alertrules enthalten auch Hinweise auf die Dokumentation!

https://github.com/kubernetes/helm / brew install kubernetes-helm
Helm benutze Packaging format "charts".  https://docs.helm.sh/developing_charts/
Ein Chart kann alles deployen, vom einfachen Pod bis zur Full-Stack-Applikation.
Think of it like apt/yum/homebrew for Kubernetes.


Monitoring-Targets:

* DeploymentConfig mit kube-state-metrics:
  kube-state-metrics is a simple service that listens to the Kubernetes API server and generates metrics about the state of the objects.
  Stellt alle API-Objekte als Prom. Metriken dar.

  "Der automatisierte Weg, beim debuggen mit kubectl oder oc get deployment den Status der Deplyments abzufragen. "
 https://github.com/kubernetes/kube-state-metrics, (II: https://www.weave.works/blog/monitoring-kubernetes-infrastructure/) Dashboard: https://grafana.com/dashboards/741
  Benutzt https://github.com/kubernetes/autoscaler/tree/master/addon-resizer

* Node exporter:
  Node exporter is a Prometheus exporter for hardware and OS metrics expose UNIX kernels.
* Config diff mit kubediff: https://www.weave.works/blog/monitoring-kubernetes-infrastructure/



Michael:
  * haproxy (1/1 up) vs. kubernetes-service-endpoints (0/1 up) -  ist das der gleiche Router?


Dashboards:
* HAproxy: https://grafana.com/dashboards/2428
* NodeEporter:


https://github.com/rbo/oc-cluster/blob/master/up



Vortrag:
Prometheus is an open source toolkit to monitor and alert, inspired by Google Borg Monitor. It was previously developed by SoundCloud and afterwards donated to the CNCF.
  * https://blog.openshift.com/wp-content/uploads/Prometheus-OpenShift-Commons-Briefing-1.pdf
  * Sakuli
  * keine Prozessüberwachungen


## Kubernetes Servicediscovery:

https://prometheus.io/docs/prometheus/latest/configuration/configuration/#kubernetes_sd_config

Automatisches Ermitteln von Scrape targets über die Kubernetes REST API

Rollentypen:
  * node: ein Target pro Clusternode
    * Adresse -> Kubelet HTTP port
  * service: ein Target pro Service (="Blackbox Exporter")
    * Adresse -> Service DNS name
  * pod: ein Target pro Pod
  * endpoint:
  * ingress
  *



## NodeExporter
Node Exporter als Daemon Set



## Routers
Router laufen im default namespace!

der router-exporter wird nicht mehr benötigt; /metrics spuckt gleich Prometheus-Daten aus


